import { Injectable } from '@nestjs/common';
import {
  TransactionHost,
  InjectTransactionHost,
} from '@nestjs-cls/transactional';
import { Prisma } from '@repo/prisma-db';
import { I{{ENTITY_NAME_PASCAL}}PrismaRepository } from './{{ENTITY_NAME_KEBAB}}.prisma-repository.interface';
import { PrismaTransactionAdapter } from '../../../prisma/prisma.module';
import { ServerConstants } from '../../../../constants/server.constants';
import { TenantContext } from '../../../tenant/tenant.context';
import { requireTenantId } from '../../../../lib/require-tenant';

function mergeWhere<T extends { where?: Prisma.{{ENTITY_NAME_PASCAL}}WhereInput } | undefined>(
  args: T,
  tenantId: string,
): T {
  const baseWhere: Prisma.{{ENTITY_NAME_PASCAL}}WhereInput = { tenantId };
  if (args == null) {
    return { where: baseWhere } as T;
  }
  return {
    ...args,
    where: { ...args.where, tenantId } as Prisma.{{ENTITY_NAME_PASCAL}}WhereInput,
  } as T;
}

@Injectable()
export class {{ENTITY_NAME_PASCAL}}PrismaRepository implements I{{ENTITY_NAME_PASCAL}}PrismaRepository {
  constructor(
    @InjectTransactionHost(ServerConstants.TransactionConnectionNames.Prisma)
    protected readonly prismaTxHost: TransactionHost<PrismaTransactionAdapter>,
    private readonly tenantContext: TenantContext,
  ) {}

  protected get delegate(): Prisma.{{ENTITY_NAME_PASCAL}}Delegate {
    return this.prismaTxHost.tx.{{ENTITY_NAME_CAMEL}};
  }

  create(
    args: Prisma.{{ENTITY_NAME_PASCAL}}CreateArgs,
  ): Promise<Prisma.{{ENTITY_NAME_PASCAL}}GetPayload<Prisma.{{ENTITY_NAME_PASCAL}}CreateArgs>> {
    const tenantId = requireTenantId(this.tenantContext.getTenantId());
    const data = {
      ...args.data,
      tenantId,
    } as unknown as Prisma.{{ENTITY_NAME_PASCAL}}CreateInput;
    return this.delegate.create({ ...args, data });
  }

  createMany(args: Prisma.{{ENTITY_NAME_PASCAL}}CreateManyArgs): Promise<Prisma.BatchPayload> {
    const tenantId = requireTenantId(this.tenantContext.getTenantId());
    const data = Array.isArray(args.data)
      ? args.data.map((row) => ({ ...row, tenantId }))
      : { ...args.data, tenantId };
    return this.delegate.createMany({
      ...args,
      data,
    } as Prisma.{{ENTITY_NAME_PASCAL}}CreateManyArgs);
  }

  findFirst(
    args?: Prisma.{{ENTITY_NAME_PASCAL}}FindFirstArgs,
  ): Promise<Prisma.{{ENTITY_NAME_PASCAL}}GetPayload<Prisma.{{ENTITY_NAME_PASCAL}}FindFirstArgs> | null> {
    const tenantId = requireTenantId(this.tenantContext.getTenantId());
    return this.delegate.findFirst(mergeWhere(args, tenantId));
  }

  findUnique(
    args: Prisma.{{ENTITY_NAME_PASCAL}}FindUniqueArgs,
  ): Promise<Prisma.{{ENTITY_NAME_PASCAL}}GetPayload<Prisma.{{ENTITY_NAME_PASCAL}}FindUniqueArgs> | null> {
    const tenantId = requireTenantId(this.tenantContext.getTenantId());
    return this.delegate.findUnique(mergeWhere(args, tenantId));
  }

  findMany(
    args?: Prisma.{{ENTITY_NAME_PASCAL}}FindManyArgs,
  ): Promise<Prisma.{{ENTITY_NAME_PASCAL}}GetPayload<Prisma.{{ENTITY_NAME_PASCAL}}FindManyArgs>[]> {
    const tenantId = requireTenantId(this.tenantContext.getTenantId());
    return this.delegate.findMany(mergeWhere(args, tenantId));
  }

  update(
    args: Prisma.{{ENTITY_NAME_PASCAL}}UpdateArgs,
  ): Promise<Prisma.{{ENTITY_NAME_PASCAL}}GetPayload<Prisma.{{ENTITY_NAME_PASCAL}}UpdateArgs>> {
    const tenantId = requireTenantId(this.tenantContext.getTenantId());
    return this.delegate.update(mergeWhere(args, tenantId));
  }

  updateMany(args: Prisma.{{ENTITY_NAME_PASCAL}}UpdateManyArgs): Promise<Prisma.BatchPayload> {
    const tenantId = requireTenantId(this.tenantContext.getTenantId());
    return this.delegate.updateMany(mergeWhere(args, tenantId));
  }

  upsert(
    args: Prisma.{{ENTITY_NAME_PASCAL}}UpsertArgs,
  ): Promise<Prisma.{{ENTITY_NAME_PASCAL}}GetPayload<Prisma.{{ENTITY_NAME_PASCAL}}UpsertArgs>> {
    const tenantId = requireTenantId(this.tenantContext.getTenantId());
    const where = { ...args.where, tenantId } as Prisma.{{ENTITY_NAME_PASCAL}}WhereUniqueInput;
    const create = {
      ...args.create,
      tenantId,
    } as unknown as Prisma.{{ENTITY_NAME_PASCAL}}CreateInput;
    const update = {
      ...args.update,
      tenantId,
    } as unknown as Prisma.{{ENTITY_NAME_PASCAL}}UpdateInput;
    return this.delegate.upsert({ ...args, where, create, update });
  }

  delete(
    args: Prisma.{{ENTITY_NAME_PASCAL}}DeleteArgs,
  ): Promise<Prisma.{{ENTITY_NAME_PASCAL}}GetPayload<Prisma.{{ENTITY_NAME_PASCAL}}DeleteArgs>> {
    const tenantId = requireTenantId(this.tenantContext.getTenantId());
    return this.delegate.delete(mergeWhere(args, tenantId));
  }

  deleteMany(args?: Prisma.{{ENTITY_NAME_PASCAL}}DeleteManyArgs): Promise<Prisma.BatchPayload> {
    const tenantId = requireTenantId(this.tenantContext.getTenantId());
    return this.delegate.deleteMany(mergeWhere(args, tenantId));
  }

  count(args?: Prisma.{{ENTITY_NAME_PASCAL}}CountArgs): Promise<number> {
    const tenantId = requireTenantId(this.tenantContext.getTenantId());
    return this.delegate.count(mergeWhere(args, tenantId));
  }

  aggregate(
    args: Prisma.{{ENTITY_NAME_PASCAL}}AggregateArgs,
  ): Promise<Prisma.Get{{ENTITY_NAME_PASCAL}}AggregateType<Prisma.{{ENTITY_NAME_PASCAL}}AggregateArgs>> {
    const tenantId = requireTenantId(this.tenantContext.getTenantId());
    return this.delegate.aggregate(mergeWhere(args, tenantId));
  }
}
